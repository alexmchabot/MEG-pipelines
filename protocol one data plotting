#this script works as intended as of 10/12/2024
#it loads ERPs and averages them

import os
import pathlib
import numpy as np
import matplotlib
matplotlib.use('Qt5Agg')
import matplotlib.pyplot as plt
import mne

# Select protocol and onset type
protocol = 'protocol01'
onset_type = 'vowel'  # or 'consonant' based on your needs

# Define dataset based on onset type
dataset = 'V_onset' if onset_type == 'vowel' else 'C_onset'
time_shift = 0.00          
ICA = True                 
reject_bad_epochs = True
date = 'October 12'            
n = 'n=14'             
special = ''     
plot_show = False                                            

ICA_file = "_ICA" if ICA else ""
reject_file = "_bad_epochs_rejected" if reject_bad_epochs else ""
data_dir = pathlib.Path(f'../../out_data/{protocol}/{dataset}')

parts = {
    'part01': 'R2830', 
    'part02': 'R2890', 
    'part03': 'R2896', 
    'part04': 'R2897', 
    'part05': 'R2900', 
    'part06': 'R2906', 
    'part07': 'R2915', 
    #'part08': 'R2968', 
    'part09': 'R2976', 
    'part10': 'R2996', 
    'part11': 'R2997', 
    'part12': 'R3005', 
    #'part13': 'R3007', 
    'part14': 'R3008'
}

erp_dict = {}

# Load the saved epochs for each participant
for part_label, participant_id in parts.items():
    try:
        evokeds = mne.read_evokeds(data_dir / f"{participant_id}_evokeds_{ICA_file}{reject_file}{special}-ave.fif", baseline=None)
        erp_dict[f"{part_label}_evokeds"] = evokeds
    except FileNotFoundError:
        print(f"File not found for {participant_id}. Skipping.")
    except Exception as e:
        print(f"An error occurred for {participant_id}: {e}. Skipping.")

# Initialize empty lists to store ERPs for each condition
ba_evokeds = []
pa_evokeds = []
fa_evokeds = []
va_evokeds = []

# Loop over participants and accumulate the ERPs for each condition
for part_label in parts:
    try:
        for evoked in erp_dict[f"{part_label}_evokeds"]:
            # Add the evoked data directly to the appropriate list based on its comment
            if 'ba' in evoked.comment:
                ba_evokeds.append(evoked)
            elif 'pa' in evoked.comment:
                pa_evokeds.append(evoked)
            elif 'fa' in evoked.comment:
                fa_evokeds.append(evoked)
            elif 'va' in evoked.comment:
                va_evokeds.append(evoked)
    except KeyError:
        print(f"Missing evokeds for {part_label}. Skipping this participant for certain conditions.")
    except Exception as e:
        print(f"An error occurred for {part_label}: {e}. Skipping.")

# Compute the average for each ERP
# Directly using the lists of evoked objects, even if they have different channels
ba_total = mne.grand_average(ba_evokeds, drop_bads=False, interpolate_bads=True)
pa_total = mne.grand_average(pa_evokeds, drop_bads=False, interpolate_bads=True)
fa_total = mne.grand_average(fa_evokeds, drop_bads=False, interpolate_bads=True)
va_total = mne.grand_average(va_evokeds, drop_bads=False, interpolate_bads=True)

# Optionally, you can print the number of evoked objects averaged for each condition
print(f"Averaged {len(ba_evokeds)} BA evokeds.")
print(f"Averaged {len(pa_evokeds)} PA evokeds.")
print(f"Averaged {len(fa_evokeds)} FA evokeds.")
print(f"Averaged {len(va_evokeds)} VA evokeds.")


# Put grand averages into a dictionary
grand_avg_dict = {
    'ba': ba_total,
    'pa': pa_total,
    'fa': fa_total,
    'va': va_total
}

# Prepare the evoked dictionary for plotting
evks = {
    'ba': grand_avg_dict['ba'],
    'pa': grand_avg_dict['pa'],
    'fa': grand_avg_dict['fa'],
    'va': grand_avg_dict['va']
}

# Print the number of events (epochs) for each grand average
for condition, grand_avg in grand_avg_dict.items():
    print(f"Condition: {condition}, Number of Events: {grand_avg.nave}")

# Create the directory to store the plots
plot_directory = pathlib.Path(f'../../out_data/{protocol}/plots/{date}{n}')
if not plot_directory.exists():
    plot_directory.mkdir(parents=True)

# Define file names for saving based on ICA variable
ICA_file = "_ICA" if ICA else ""

# Define info for the plots
color_dict = {'pa': 'gray', 'ba': 'blue', 'fa': 'green', 'va': 'red'}
linestyle_dict = {'pa': '-', 'ba': '-', 'fa': '-', 'va': '-'}

# Plot all channels for all participants (GFP, Mean, Butterfly, Topo)
# Plot comparing all grand averages
fig = mne.viz.plot_compare_evokeds(evks,
                                   ci=False,
                                   legend='upper left',
                                   show_sensors='upper right',
                                   colors=color_dict,
                                   linestyles=linestyle_dict,
                                   title=f'{protocol} participants ({n}), {onset_type} onset{ICA_file} {special} {reject_file}',
                                   show=plot_show)   # if plot_show=True, it displays the plot but won't save correctly
plt.savefig(f'{plot_directory}/ERP_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_.pdf')
plt.close()

# Plot comparing all grand averages with the mean combine
fig = mne.viz.plot_compare_evokeds(evks,
                                   combine='mean',
                                   ci=False,
                                   legend='upper left',
                                   show_sensors='upper right',
                                   colors=color_dict,
                                   linestyles=linestyle_dict,
                                   title=f'{protocol} participants ({n}), {onset_type} onset {ICA_file} {special} mean {reject_file}',
                                   show=plot_show)
plt.savefig(f'{plot_directory}/ERP_{onset_type}{ICA_file}mean_{special}{reject_file}_ERP_set_.pdf')
plt.close()

#butterfly plots of all conditions

# Store the grand averages in a dictionary
evks = {
    'ba': ba_total,
    'pa': pa_total,
    'fa': fa_total,
    'va': va_total
}

#create subplots for the butterfly plots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(10, 8))

#access each evoked object from the dictionary using its key
evks['pa'].plot(exclude='bads', spatial_colors=True, axes=axes[0, 0], show=False)
axes[0, 0].set_title('PA evoked, all channels')

evks['ba'].plot(exclude='bads', spatial_colors=True, axes=axes[0, 1], show=False)
axes[0, 1].set_title('BA evoked, all channels')

evks['fa'].plot(exclude='bads', spatial_colors=True, axes=axes[1, 0], show=False)
axes[1, 0].set_title('FA evoked, all channels')

evks['va'].plot(exclude='bads', spatial_colors=True, axes=axes[1, 1], show=False)
axes[1, 1].set_title('VA evoked, all channels')

#calculate the maximum ylim value among the four plots
max_ylim = max([ax.get_ylim()[1] for ax in axes.flatten()])

#set the same ylim value for all subplots
for ax in axes.flatten():
    ax.set_ylim([-max_ylim, max_ylim])

#add a title to the plot
plt.suptitle(f'{protocol} All channels {onset_type} onset {ICA_file}{special} {reject_file}', fontsize=14)

#show the plot
if plot_show:
    plt.show()

#save the figure
plt.savefig(f'{plot_directory}/butterfly4conditions_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_.pdf')
plt.close()

#create a 3x6 grid of subplots
fig, axs = plt.subplots(4, 6, figsize=(16, 12), gridspec_kw={'height_ratios': [1, 1, 1, 1], 'hspace': 0})

times = [0.150, 0.200, 0.250, 0.300, 0.350, 0.400]

#plot the second topographic map on the middle subplot
evks['pa'].plot_topomap(times=times, ch_type='mag', axes=axs[0, :], show=False, colorbar=False)

#plot the third topographic map on the bottom subplot
evks['ba'].plot_topomap(times=times, ch_type='mag', axes=axs[1, :], show=False, colorbar=False)

#plot the third topographic map on the bottom subplot
evks['fa'].plot_topomap(times=times, ch_type='mag', axes=axs[2, :], show=False, colorbar=False)

#plot the third topographic map on the bottom subplot
evks['va'].plot_topomap(times=times, ch_type='mag', axes=axs[3, :], show=False, colorbar=False)

# Add captions to each row relative to the subplots
for i, label in enumerate(['PA evoked', 'BA evoked', 'FA evoked', 'VA evoked']):
    # Place text above the left-most subplot in each row
    axs[i, 0].text(-0.1, 1.05, label, transform=axs[i, 0].transAxes, fontsize=12, va='center', ha='right')

# Add a global caption
fig.suptitle(f'{protocol} MEG Topographic Plots: 150-400 ms, {time_shift} {onset_type} onset {ICA_file}{special}{reject_file}')


#adjust spacing between subplots
plt.subplots_adjust(hspace=0.4, wspace=0.2)

#show the plot
if plot_show:
    plt.show()

#save the figure
plt.savefig(f'{plot_directory}/topos_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_.pdf')
plt.close()

# Get the channel names for left hemisphere (based on negative x-coordinate)
left_hemisphere_chs = [ch_name for ch_name, pos in zip(evoked.info['ch_names'], evoked.info['chs']) if pos['loc'][0] < 0]

# Instead of using evks with averaged evokeds, pass the list of Evoked objects for each condition
evks = dict(
    ba=ba_evokeds,  # List of Evoked objects for 'ba'
    pa=pa_evokeds,  # List of Evoked objects for 'pa'
    fa=fa_evokeds,  # List of Evoked objects for 'fa'
    va=va_evokeds   # List of Evoked objects for 'va'
)

mne.viz.plot_compare_evokeds(evks,
                             ci=False,
                             combine='gfp',
                             picks=left_hemisphere_chs,
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, left hemisphere channels',
                             show=plot_show
                             )
plt.savefig(f'{plot_directory}/ERP_left_hemisphere_chans_{onset_type}{ICA_file}{special}{reject_file}_ERP_set.pdf')
plt.close()

mne.viz.plot_compare_evokeds(evks,
                             combine='gfp',
                             picks=left_hemisphere_chs,
                             ci=.50,  # Confidence interval
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, left hemisphere channels',
                             show=plot_show
                             )
plt.savefig(f'{plot_directory}/ERP_left_hemisphere_chans_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_CI_50.pdf')
plt.close()

mne.viz.plot_compare_evokeds(evks,
                             combine='gfp',
                             picks=left_hemisphere_chs,
                             ci=.95,  # Confidence interval
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, left hemisphere channels',
                             show=plot_show
                             )
plt.savefig(f'{plot_directory}/ERP_left_hemisphere_chans_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_CI_95.pdf')
plt.close()

mne.viz.plot_compare_evokeds(evks,
                             combine='gfp',
                             picks=left_hemisphere_chs,
                             ci=.95,  # Confidence interval
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, left hemisphere channels',
                             show=True
                             )


#channel selection, plot only dipole on left hemisphere by looking for highest absolute amplitude channels in left hemisphere

# Define values for cropping the evoked data to the time span of interest
crop_min = 0.170  # Start time for cropping
crop_max = 0.350  # End time for cropping

# Initialize empty lists to store cropped evoked objects
evks_crop_ba = []
evks_crop_pa = []
evks_crop_fa = []
evks_crop_va = []

# Crop the evoked objects for each condition
for evoked in evks['ba']:
    evks_crop_ba.append(evoked.copy().crop(tmin=crop_min, tmax=crop_max))

for evoked in evks['pa']:
    evks_crop_pa.append(evoked.copy().crop(tmin=crop_min, tmax=crop_max))

for evoked in evks['fa']:
    evks_crop_fa.append(evoked.copy().crop(tmin=crop_min, tmax=crop_max))

for evoked in evks['va']:
    evks_crop_va.append(evoked.copy().crop(tmin=crop_min, tmax=crop_max))

# Combine the cropped evoked objects into single evoked objects for each condition
evks_crop_ba = mne.combine_evoked(evks_crop_ba, weights='equal')
evks_crop_pa = mne.combine_evoked(evks_crop_pa, weights='equal')
evks_crop_fa = mne.combine_evoked(evks_crop_fa, weights='equal')
evks_crop_va = mne.combine_evoked(evks_crop_va, weights='equal')

# Now combine all evoked conditions into a single evoked object
evks_crop = mne.combine_evoked([evks_crop_ba, evks_crop_pa, evks_crop_fa, evks_crop_va], weights='equal')

# Get the channel names for the left hemisphere (based on negative x-coordinate)
left_hemisphere_chs = [ch_name for ch_name, pos in zip(evks_crop.ch_names, evks_crop.info['chs']) if pos['loc'][0] < 0]

# Get the indices of the left hemisphere channels
left_hemi_indices = [evks_crop.ch_names.index(ch) for ch in left_hemisphere_chs]

# Check if any left hemisphere channels were found
if not left_hemi_indices:
    print("No left hemisphere channels found for plotting.")
else:
    # Calculate the max and min amplitudes for the left hemisphere channels only
    max_amps_left = np.max(evks_crop.data[left_hemi_indices, :], axis=1)
    min_amps_left = np.min(evks_crop.data[left_hemi_indices, :], axis=1)
    
    # Sort the left hemisphere channels by maximum and minimum amplitudes
    sorted_max_indices = np.argsort(max_amps_left)[-10:][::-1]  # Indices for highest amplitudes
    sorted_min_indices = np.argsort(min_amps_left)[:10]  # Indices for lowest amplitudes
    
    # Select the corresponding channel indices from left_hemi_indices
    highest_channels_left = [left_hemi_indices[i] for i in sorted_max_indices]
    lowest_channels_left = [left_hemi_indices[i] for i in sorted_min_indices]
    
    # Print the channel names and amplitudes
    print('Left hemisphere channels with highest amplitudes:')
    for i, ch in enumerate(highest_channels_left):
        print(f'{i+1}. {evks_crop.ch_names[ch]}: {max_amps_left[sorted_max_indices[i]]:.3f}')
    
    print('\nLeft hemisphere channels with lowest amplitudes:')
    for i, ch in enumerate(lowest_channels_left):
        print(f'{i+1}. {evks_crop.ch_names[ch]}: {min_amps_left[sorted_min_indices[i]]:.3f}')
    
    # Combine the highest and lowest channels and ensure no duplicates
    peak_channels_left = list(set(highest_channels_left) | set(lowest_channels_left))
    
    # Plot the evoked responses for the extreme left hemisphere channels
    evks_crop.plot(exclude='bads', picks=peak_channels_left, window_title='Evoked Responses (Left Hemisphere)', show=True)

mne.viz.plot_compare_evokeds(evks,
                             ci=False,
                             combine='gfp',
                             picks=peak_channels_left,
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, most active left hemisphere channels',
                             show=plot_show
                             )
plt.savefig(f'{plot_directory}/ERP_most_active_left_hemisphere_chans_{onset_type}{ICA_file}{special}{reject_file}_ERP_set.pdf')
plt.close()

mne.viz.plot_compare_evokeds(evks,
                             ci=.95,
                             combine='gfp',
                             picks=peak_channels_left,
                             legend='upper left',
                             show_sensors='upper right',
                             colors=color_dict,
                             linestyles=linestyle_dict,
                             title=f'All participants ({n}): deviant conditions, most active left hemisphere channels',
                             show=plot_show
                             )
plt.savefig(f'{plot_directory}/ERP_most_active_left_hemisphere_chans_{onset_type}{ICA_file}{special}{reject_file}_ERP_set_CI_95.pdf')
plt.close()
